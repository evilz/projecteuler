@namespace Projecteuler.Components.Problems
@page "/problem/43"
@inherits ProblemBase

@{
    base.BuildRenderTree(__builder);
}

@code {
    protected override int Ref => 43;

    protected override string ProblemTitle => "Sub-string Divisibility";

    protected override string Description => "<p>The number, $1406357289$, is a $0$ to $9$ pandigital number because it is made up of each of the digits $0$ to $9$ in some order, but it also has a rather interesting sub-string divisibility property.</p>\n<p>Let $d_1$ be the $1$<sup>st</sup> digit, $d_2$ be the $2$<sup>nd</sup> digit, and so on. In this way, we note the following:</p>\n<ul><li>$d_2d_3d_4=406$ is divisible by $2$</li>\n<li>$d_3d_4d_5=063$ is divisible by $3$</li>\n<li>$d_4d_5d_6=635$ is divisible by $5$</li>\n<li>$d_5d_6d_7=357$ is divisible by $7$</li>\n<li>$d_6d_7d_8=572$ is divisible by $11$</li>\n<li>$d_7d_8d_9=728$ is divisible by $13$</li>\n<li>$d_8d_9d_{10}=289$ is divisible by $17$</li>\n</ul><p>Find the sum of all $0$ to $9$ pandigital numbers with this property.</p>";

    protected override string Explanation => "We generate all 10-digit pandigital numbers (excluding those with a leading zero) and check each for the specified sub-string divisibility property using the divisors 2, 3, 5, 7, 11, 13, and 17.";

    protected override long Resolve()
    {
        long sum = 0;
        int[] digits = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        foreach (var p in GetPermutations(digits))
        {
            if (p[0] == 0) continue;
            if (HasProperty(p))
            {
                sum += long.Parse(string.Join("", p));
            }
        }
        return sum;
    }

    private IEnumerable<int[]> GetPermutations(int[] list)
    {
        int n = list.Length;
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = list[i];

        yield return (int[])a.Clone();

        while (true)
        {
            int i = n - 2;
            while (i >= 0 && a[i] >= a[i + 1]) i--;
            if (i < 0) break;

            int j = n - 1;
            while (a[j] <= a[i]) j--;

            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;

            Array.Reverse(a, i + 1, n - i - 1);
            yield return (int[])a.Clone();
        }
    }

    private bool HasProperty(int[] p)
    {
        int[] divisors = { 2, 3, 5, 7, 11, 13, 17 };
        for (int i = 0; i < 7; i++)
        {
            int num = p[i + 1] * 100 + p[i + 2] * 10 + p[i + 3];
            if (num % divisors[i] != 0) return false;
        }
        return true;
    }
}


